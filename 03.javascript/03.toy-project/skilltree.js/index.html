<!DOCTYPE html>
<html>
<head>
    <title>Skill Tree Visualization</title>
    <style id="dynamicStyles">

/* Define rarity colors */
:root {
    --rarity-gold: #FFD700;
    --rarity-orange: #FFA500;
    --rarity-purple: #800080;
    --rarity-blue: #0000FF;
    --rarity-green: #008000;
    --rarity-white: #FFFFFF;
}

body {
    margin: 0;
    overflow: hidden;
    background: #1a1a1a;
}

#container {
    width: 100vw;
    height: 100vh;
    position: relative;
}

#skillTree {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

/* Base node styles */
.node {
    position: absolute;
    width: 60px;
    height: 60px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 10px;
    font-size: 12px;
    word-wrap: break-word;
    overflow: visible;
    position: relative;
    background-clip: padding-box;
}

/* Star shape with outline */
.node.fundamental {
    width: 110px;
    height: 90px;
    background-clip: padding-box;
    position: relative;
}

.node.fundamental::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    clip-path: polygon(
        50% 0%,
        61% 35%,
        98% 35%,
        68% 57%,
        79% 91%,
        50% 70%,
        21% 91%,
        32% 57%,
        2% 35%,
        39% 35%
    );
    z-index: -1;
}


/* Diamond shape */
.node.major {
    width: 70px;
    height: 70px;
}
.node.major::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    z-index: -1;
}

/* Circle shape */
.node.minor {
    width: 60px;
    height: 60px;
    border-radius: 50%;
}
.node.minor::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    border-radius: 50%;
    z-index: -1;
}

/* Square shape */
.node.keystone {
    width: 65px;
    height: 65px;
}
.node.keystone::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    z-index: -1;
}


/* Rarity colors */
.node.rarity-gold::before { background-color: var(--rarity-gold); }
.node.rarity-orange::before { background-color: var(--rarity-orange); }
.node.rarity-purple::before { background-color: var(--rarity-purple); }
.node.rarity-blue::before { background-color: var(--rarity-blue); }
.node.rarity-green::before { background-color: var(--rarity-green); }
.node.rarity-white::before { background-color: var(--rarity-white); }

.edge {
    position: absolute;
    background: #4a90e2;
    height: 4px;         /* Made thicker */
    pointer-events: none;
    transition: all 0.3s;
    transform-origin: left center;
    z-index: -1;         /* Added to ensure edges appear under nodes */
}

.edge::after {
    content: '';
    position: absolute;
    right: -8px;
    top: -6px;          /* Adjusted for thicker line */
    width: 0;
    height: 0;
    border-left: 12px solid #4a90e2;  /* Made arrow bigger */
    border-top: 7px solid transparent;
    border-bottom: 7px solid transparent;
}

.edge.active {
    background: #00ff00;
}

.edge.active::after {
    border-left-color: #00ff00;
}

#controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
}

#stats {
    position: fixed;
    top: 20px;
    left: 20px;
    color: white;
    z-index: 1000;
}

/* Add these styles */
#legend {
    margin-top: 20px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
}

.legend-title {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 10px;
    color: white;
}

.legend-item {
    display: flex;
    align-items: center;
    margin: 5px 0;
}

.color-box {
    width: 20px;
    height: 20px;
    border-radius: 4px;
    margin-right: 10px;
    border: 1px solid rgba(255, 255, 255, 0.3);
}

/* Grid styles */
.grid {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: -2;
}

.grid-line {
    stroke: rgba(255, 255, 255, 0.1);
    stroke-width: 1;
}

	</style>
</head>
<body>
    <div id="container">
        <div id="skillTree"></div>
        <div id="stats">
            <div>Active Nodes: <span id="activeNodes">0</span></div>
            <div>Active Edges: <span id="activeEdges">0</span></div>
            <div id="legend">
                <div class="legend-title">Domains:</div>
                <div class="legend-item">
                    <div class="color-box" style="background-color: #4A90E2"></div>
                    <span>Learn</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background-color: #F5A623"></div>
                    <span>Computer Science</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background-color: #7ED321"></div>
                    <span>Web Development</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background-color: #BD10E0"></div>
                    <span>Math</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background-color: #FF5733"></div>
                    <span>Machine Learning</span>
                </div>
            </div>
        </div>
        <div id="controls">
            <button id="zoomIn">+</button>
            <button id="zoomOut">-</button>
            <button id="fitScreen">Fit Screen</button>
        </div>
    </div>
	<script>
class SkillTree {
    constructor(containerId, data) {
        this.container = document.getElementById(containerId);
        this.data = data;
        this.scale = 1;
        this.dragStart = { x: 0, y: 0 };
        this.offset = { x: 0, y: 0 };
        this.activeNodes = new Set();
        this.activeEdges = new Set();

        this.showGrid = true;  // Add this
        this.data.domains = {
            "learn": "#4A90E2",
            "computer-science": "#F5A623",
            "web-development": "#7ED321",
            "math": "#BD10E0",
            "machine-learning": "#FF5733"
        };

        this.init();
    }

    createGrid() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.classList.add('grid');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');

        // Create grid lines
        const gridSize = 50;
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;

        // Vertical lines
        for (let x = 0; x <= width; x += gridSize) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', x);
            line.setAttribute('y1', 0);
            line.setAttribute('x2', x);
            line.setAttribute('y2', height);
            line.classList.add('grid-line');
            svg.appendChild(line);
        }

        // Horizontal lines
        for (let y = 0; y <= height; y += gridSize) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', 0);
            line.setAttribute('y1', y);
            line.setAttribute('x2', width);
            line.setAttribute('y2', y);
            line.classList.add('grid-line');
            svg.appendChild(line);
        }

        this.container.appendChild(svg);
    }

    isEdgeActive(edge) {
        const sourceNode = this.findNodeData(edge.source);
        const targetNode = this.findNodeData(edge.target);
        return sourceNode.explored && targetNode.explored;
    }

    init() {
        this.setupContainer();
        this.createGrid();
        this.createNodes();
        this.createEdges();
        this.setupEventListeners();
        this.updateStats();
    }

    setupContainer() {
        this.container.style.transform = `scale(${this.scale})
            translate(${this.offset.x}px, ${this.offset.y}px)`;
    }

    createNodes() {
        // Create nodes for each type
        Object.entries(this.data.nodes).forEach(([type, nodes]) => {
            if (Array.isArray(nodes)) {
                nodes.forEach(node => this.createNode(node));
            } else {
                this.createNode(nodes);
            }
        });
    }

    createNode(nodeData) {
        const node = document.createElement('div');
        node.className = `node ${nodeData.type}`;
        
        // Add rarity class
        if (nodeData.rarity) {
            node.classList.add(`rarity-${nodeData.rarity}`);
        } else {
            node.classList.add('rarity-white'); // default rarity
        }
        
        node.id = nodeData.id;
        node.style.left = `${nodeData.position.x}px`;
        node.style.top = `${nodeData.position.y}px`;

        // Create inner container for content
        const innerContainer = document.createElement('div');
        innerContainer.style.width = '100%';
        innerContainer.style.height = '100%';
        innerContainer.style.display = 'flex';
        innerContainer.style.alignItems = 'center';
        innerContainer.style.justifyContent = 'center';
        innerContainer.style.padding = '5px';
        innerContainer.style.clipPath = this.getClipPath(nodeData.type);
        innerContainer.style.backgroundColor = nodeData.explored ? 
            this.data.domains[nodeData.domain] : '#333';

        if (nodeData.explored) {
            this.activeNodes.add(nodeData.id);
            this.createTextContainer(innerContainer, nodeData.title);
        } else {
            innerContainer.textContent = '?';
        }
        
        node.appendChild(innerContainer);
        
        this.container.appendChild(node);
    }

    getClipPath(type) {
        switch(type) {
            case 'fundamental':
                return 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)';
            case 'major':
                return 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)';
            case 'minor':
                return 'circle(50%)';
            case 'keystone':
                return 'none';
            default:
                return 'none';
        }
    }

    createTextContainer(container, text) {
        if (text.length > 20) {
            container.style.fontSize = '9px';
        } else if (text.length > 15) {
            container.style.fontSize = '10px';
        } else if (text.length > 10) {
            container.style.fontSize = '11px';
        } else {
            container.style.fontSize = '12px';
        }
        
        container.textContent = text;
    }

    createEdges() {
        // Get all nodes in a flat array
        const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
        
        // Create edges from connections
        allNodes.forEach(node => {
            if (node.connections) {
                node.connections.forEach(targetId => {
                    const edgeElement = document.createElement('div');
                    edgeElement.className = 'edge';
                    this.updateEdgePosition(edgeElement, node.id, targetId);
                    edgeElement.dataset.source = node.id;
                    edgeElement.dataset.target = targetId;
                    this.container.appendChild(edgeElement);

                    // If both nodes are explored, activate the edge
                    if (node.explored && this.findNodeData(targetId).explored) {
                        this.activeEdges.add(`${node.id}-${targetId}`);
                        edgeElement.classList.add('active');
                    }
                });
            }
        });
    }

    updateEdgePosition(edgeElement, sourceId, targetId) {
        const source = document.getElementById(sourceId);
        const target = document.getElementById(targetId);

        if (!source || !target) return;

        const sourceRect = source.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // Get positions relative to container
        const containerRect = this.container.getBoundingClientRect();
        const relativeSourceX = sourceRect.left - containerRect.left + sourceRect.width/2;
        const relativeSourceY = sourceRect.top - containerRect.top + sourceRect.height/2;
        const relativeTargetX = targetRect.left - containerRect.left + targetRect.width/2;
        const relativeTargetY = targetRect.top - containerRect.top + targetRect.height/2;

        // Calculate distance and angle
        const dx = relativeTargetX - relativeSourceX;
        const dy = relativeTargetY - relativeSourceY;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        const length = Math.sqrt(dx * dx + dy * dy);

        // Position the edge
        edgeElement.style.width = `${length}px`;
        edgeElement.style.left = `${relativeSourceX}px`;
        edgeElement.style.top = `${relativeSourceY}px`;
        edgeElement.style.transform = `rotate(${angle}deg)`;
    }

    setupEventListeners() {
        // Node click handling
        this.container.addEventListener('click', (e) => {
            const node = e.target.closest('.node');
            if (node) {
                this.toggleNode(node);
            }
        });

        // Dragging
        let isDragging = false;
        let startX, startY;

        this.container.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - this.offset.x;
            startY = e.clientY - this.offset.y;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            this.offset.x = e.clientX - startX;
            this.offset.y = e.clientY - startY;
            this.updateTransform();
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Zooming
        document.getElementById('zoomIn').addEventListener('click', () => {
            this.scale *= 1.2;
            this.updateTransform();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            this.scale /= 1.2;
            this.updateTransform();
        });

        document.getElementById('fitScreen').addEventListener('click', () => {
            this.fitToScreen();
        });

        // Mouse wheel zooming
        this.container.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.scale *= delta;
            this.updateTransform();
        });
    }

    toggleNode(node) {
        const nodeId = node.id;
        if (this.activeNodes.has(nodeId)) {
            this.deactivateNode(node);
        } else {
            this.activateNode(node);
        }
        this.updateStats();
    }
    activateNode(node) {
        const nodeId = node.id;
        const nodeData = this.findNodeData(nodeId);
        
        this.activeNodes.add(nodeId);
        node.style.backgroundColor = this.data.domains[nodeData.domain];
        node.innerHTML = '';  // Clear before adding text container
        this.createTextContainer(node, nodeData.title);

        // Activate connected edges
        const nodeWithConnections = this.findNodeData(nodeId);
        if (nodeWithConnections.connections) {
            nodeWithConnections.connections.forEach(targetId => {
                if (this.activeNodes.has(targetId)) {
                    this.activeEdges.add(`${nodeId}-${targetId}`);
                    const edgeElement = this.findEdgeElement({source: nodeId, target: targetId});
                    if (edgeElement) edgeElement.classList.add('active');
                }
            });
        }

        // Check if this node is a target of any other node's connections
        const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
        allNodes.forEach(sourceNode => {
            if (sourceNode.connections && sourceNode.connections.includes(nodeId) && this.activeNodes.has(sourceNode.id)) {
                this.activeEdges.add(`${sourceNode.id}-${nodeId}`);
                const edgeElement = this.findEdgeElement({source: sourceNode.id, target: nodeId});
                if (edgeElement) edgeElement.classList.add('active');
            }
        });
    }

    deactivateNode(node) {
        const nodeId = node.id;
        this.activeNodes.delete(nodeId);
        node.style.backgroundColor = '#333';
        node.innerHTML = '?';

        // Deactivate connected edges
        const nodeWithConnections = this.findNodeData(nodeId);
        if (nodeWithConnections.connections) {
            nodeWithConnections.connections.forEach(targetId => {
                this.activeEdges.delete(`${nodeId}-${targetId}`);
                const edgeElement = this.findEdgeElement({source: nodeId, target: targetId});
                if (edgeElement) edgeElement.classList.remove('active');
            });
        }

        // Check for incoming connections
        const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
        allNodes.forEach(sourceNode => {
            if (sourceNode.connections && sourceNode.connections.includes(nodeId)) {
                this.activeEdges.delete(`${sourceNode.id}-${nodeId}`);
                const edgeElement = this.findEdgeElement({source: sourceNode.id, target: nodeId});
                if (edgeElement) edgeElement.classList.remove('active');
            }
        });
    }

    updateEdgeStyle(edge) {
        const edgeId = `${edge.source}-${edge.target}`;
        const edgeElement = this.findEdgeElement(edge);
        if (edgeElement) {
            if (this.activeEdges.has(edgeId)) {
                edgeElement.classList.add('active');
            } else {
                edgeElement.classList.remove('active');
            }
        }
    }

    findNodeData(nodeId) {
        const allNodes = Object.values(this.data.nodes).flat().filter(node => node);
        return allNodes.find(node => node.id === nodeId);
    }

    findEdgeElement(edge) {
        return Array.from(this.container.getElementsByClassName('edge'))
        .find(el => 
            el.dataset.source === edge.source && 
            el.dataset.target === edge.target
        );
    }

    updateTransform() {
        this.container.style.transform =
            `scale(${this.scale}) translate(${this.offset.x}px, ${this.offset.y}px)`;
    }

    fitToScreen() {
        const nodes = Array.from(this.container.getElementsByClassName('node'));
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        nodes.forEach(node => {
            const rect = node.getBoundingClientRect();
            minX = Math.min(minX, rect.left);
            maxX = Math.max(maxX, rect.right);
            minY = Math.min(minY, rect.top);
            maxY = Math.max(maxY, rect.bottom);
        });

        const width = maxX - minX;
        const height = maxY - minY;
        const containerRect = this.container.parentElement.getBoundingClientRect();

        this.scale = Math.min(
            containerRect.width / width,
            containerRect.height / height
        ) * 0.9;

        this.offset.x = (containerRect.width - width) / 2;
        this.offset.y = (containerRect.height - height) / 2;

        this.updateTransform();
    }

    updateStats() {
        document.getElementById('activeNodes').textContent =
            this.activeNodes.size;
        document.getElementById('activeEdges').textContent =
            this.activeEdges.size;
    }

    // Add method to toggle grid
    toggleGrid() {
        this.showGrid = !this.showGrid;
        const grid = this.container.querySelector('.grid');
        if (grid) {
            grid.style.display = this.showGrid ? 'block' : 'none';
        }
    }

}


fetch('skill-tree.json')
	.then(response => response.json())
	.then(data => {
		const skillTree = new SkillTree('skillTree', data);
});

	</script>
</body>
</html>
